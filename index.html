<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì›ì˜ ë„“ì´ì™€ ì›ì£¼ìœ¨ ì‹œê°í™” í•™ìŠµ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700;800&display=swap');
        
        body {
            font-family: 'Nanum Gothic', sans-serif;
            touch-action: pan-y; /* ìˆ˜ì§ ìŠ¤í¬ë¡¤ í—ˆìš©, ìˆ˜í‰ì€ ìº”ë²„ìŠ¤ì— ë§¡ê¹€ */
        }

        /* íƒ­ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .tab-btn {
            transition: all 0.2s;
            border-bottom: 4px solid transparent;
        }
        .tab-btn.active {
            border-bottom-color: #3b82f6; /* blue-500 */
            color: #1d4ed8; /* blue-700 */
            background-color: #eff6ff; /* blue-50 */
        }
        
        /* ìº”ë²„ìŠ¤ ì»¤ì„œ */
        .drag-cursor { cursor: grab; }
        .drag-cursor:active { cursor: grabbing; }

        /* ìŠ¬ë¼ì´ë” ìŠ¤íƒ€ì¼ */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #cbd5e1;
            border-radius: 2px;
        }

        /* ë§í’ì„  ìŠ¤íƒ€ì¼ */
        .bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            padding: 5px 12px;
            border-radius: 10px;
            border: 2px solid #3b82f6;
            font-weight: bold;
            color: #1e3a8a;
            pointer-events: none;
            font-size: 0.95rem;
            transform: translate(-50%, -120%);
            white-space: nowrap;
            z-index: 20;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        .bubble::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            margin-left: -6px;
            border-width: 6px 6px 0;
            border-style: solid;
            border-color: #3b82f6 transparent transparent transparent;
        }

        /* ìŠ¤í¬ë¡¤ë°” ìŠ¤íƒ€ì¼ë§ (ì„¸ë ¨ë˜ê²Œ) */
        #canvas-wrapper::-webkit-scrollbar {
            height: 10px;
        }
        #canvas-wrapper::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        #canvas-wrapper::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 5px;
        }
        #canvas-wrapper::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body class="bg-slate-50 h-screen flex flex-col overflow-hidden">

    <!-- í—¤ë” -->
    <header class="bg-indigo-600 text-white p-3 shadow-lg flex-none z-20">
        <div class="max-w-6xl mx-auto flex justify-between items-center">
            <h1 class="text-xl md:text-2xl font-extrabold flex items-center gap-2">
                <i class="fas fa-shapes"></i> ì›ì˜ ë„“ì´ íƒí—˜ëŒ€
            </h1>
            <div class="text-xs md:text-sm bg-indigo-700 px-3 py-1 rounded-full border border-indigo-400">
                6í•™ë…„ 2í•™ê¸°
            </div>
        </div>
    </header>

    <!-- íƒ­ ë„¤ë¹„ê²Œì´ì…˜ -->
    <nav class="bg-white border-b border-slate-200 flex-none z-10">
        <div class="max-w-6xl mx-auto flex justify-center text-sm md:text-base font-bold text-slate-500">
            <button onclick="switchTab('circumference')" id="tab-circumference" class="tab-btn active flex-1 py-3 text-center hover:bg-slate-50">
                <i class="fas fa-circle-notch mr-1"></i> 1. ì›ì£¼ì™€ ì›ì£¼ìœ¨
            </button>
            <button onclick="switchTab('area-rect')" id="tab-area-rect" class="tab-btn flex-1 py-3 text-center hover:bg-slate-50">
                <i class="fas fa-vector-square mr-1"></i> 2. ë„“ì´ (ì§ì‚¬ê°í˜•)
            </button>
            <button onclick="switchTab('area-tri')" id="tab-area-tri" class="tab-btn flex-1 py-3 text-center hover:bg-slate-50">
                <i class="fas fa-caret-up mr-1"></i> 3. ë„“ì´ (ì‚¼ê°í˜•)
            </button>
        </div>
    </nav>

    <!-- ì»¨íŠ¸ë¡¤ íŒ¨ë„ -->
    <section class="bg-white p-3 border-b border-slate-200 flex-none z-10 shadow-sm">
        <div class="max-w-6xl mx-auto flex flex-col md:flex-row gap-4 items-center justify-center md:justify-between h-auto md:h-12">
            
            <!-- ê³µí†µ: ì§€ë¦„ ì…ë ¥ -->
            <div id="common-controls" class="flex items-center gap-2">
                <label class="font-bold text-slate-700 text-sm">ì§€ë¦„:</label>
                <div class="flex items-center bg-white border-2 border-slate-300 rounded px-2 py-1 focus-within:border-blue-500">
                    <input type="number" id="diameterInput" value="4" min="2" max="8" step="0.1"
                           class="w-16 bg-transparent text-center font-bold text-slate-700 outline-none"
                           onchange="updateDiameter()">
                    <span class="text-xs text-slate-500">cm</span>
                </div>
            </div>

            <!-- ëª¨ë“œë³„ ì»¨íŠ¸ë¡¤ -->
            <div class="flex-grow flex justify-center items-center w-full md:w-auto">
                
                <!-- 1. ì›ì£¼ ëª¨ë“œ -->
                <div id="ctrl-circumference" class="control-group flex gap-2">
                    <span class="text-sm text-slate-500 self-center mr-2">ì›ì„ ë“œë˜ê·¸í•˜ì—¬ êµ´ë¦¬ì„¸ìš”!</span>
                    <button onclick="resetPosition()" class="bg-orange-500 hover:bg-orange-600 text-white px-3 py-1 rounded text-sm font-bold shadow">
                        <i class="fas fa-undo"></i> ì²˜ìŒìœ¼ë¡œ
                    </button>
                </div>

                <!-- 2. ì§ì‚¬ê°í˜• ëª¨ë“œ -->
                <div id="ctrl-area-rect" class="control-group hidden flex flex-col md:flex-row gap-3 w-full md:w-auto items-center">
                    <div class="flex gap-1 overflow-x-auto max-w-[300px] md:max-w-none pb-1 md:pb-0 hide-scrollbar">
                        <button onclick="setSplit(8)" class="split-btn bg-slate-200 hover:bg-blue-100 text-slate-700 px-2 py-1 rounded text-xs font-bold transition border border-slate-300">8ì¡°ê°</button>
                        <button onclick="setSplit(16)" class="split-btn bg-slate-200 hover:bg-blue-100 text-slate-700 px-2 py-1 rounded text-xs font-bold transition border border-slate-300">16</button>
                        <button onclick="setSplit(32)" class="split-btn bg-slate-200 hover:bg-blue-100 text-slate-700 px-2 py-1 rounded text-xs font-bold transition border border-slate-300">32</button>
                        <button onclick="setSplit(64)" class="split-btn bg-slate-200 hover:bg-blue-100 text-slate-700 px-2 py-1 rounded text-xs font-bold transition border border-slate-300">64</button>
                        <button onclick="setSplit(128)" class="split-btn bg-slate-200 hover:bg-blue-100 text-slate-700 px-2 py-1 rounded text-xs font-bold transition border border-slate-300">128</button>
                    </div>
                    <div class="flex items-center gap-2 border-l pl-3 border-slate-300">
                        <label class="text-xs font-bold text-blue-600 whitespace-nowrap">ë³€í˜• ê³¼ì •:</label>
                        <input type="range" id="rect-slider" min="0" max="100" value="0" class="w-32 md:w-48" oninput="updateTransform(this.value)">
                    </div>
                </div>

                <!-- 3. ì‚¼ê°í˜• ëª¨ë“œ -->
                <div id="ctrl-area-tri" class="control-group hidden flex flex-col md:flex-row gap-3 w-full md:w-auto items-center">
                     <div class="flex gap-1 overflow-x-auto max-w-[300px] md:max-w-none pb-1 md:pb-0 hide-scrollbar">
                        <button onclick="setSplit(4)" class="split-btn bg-slate-200 hover:bg-blue-100 text-slate-700 px-2 py-1 rounded text-xs font-bold transition border border-slate-300">4ê°œ</button>
                        <button onclick="setSplit(8)" class="split-btn bg-slate-200 hover:bg-blue-100 text-slate-700 px-2 py-1 rounded text-xs font-bold transition border border-slate-300">8ê°œ</button>
                        <button onclick="setSplit(16)" class="split-btn bg-slate-200 hover:bg-blue-100 text-slate-700 px-2 py-1 rounded text-xs font-bold transition border border-slate-300">16</button>
                        <button onclick="setSplit(32)" class="split-btn bg-slate-200 hover:bg-blue-100 text-slate-700 px-2 py-1 rounded text-xs font-bold transition border border-slate-300">32</button>
                    </div>
                    <div class="flex items-center gap-2 border-l pl-3 border-slate-300">
                        <label class="text-xs font-bold text-green-600 whitespace-nowrap">í¼ì¹˜ê¸°:</label>
                        <input type="range" id="tri-slider" min="0" max="100" value="0" class="w-32 md:w-48" oninput="updateTransform(this.value)">
                    </div>
                </div>

            </div>
        </div>
    </section>

    <!-- ë©”ì¸ ìº”ë²„ìŠ¤ ì˜ì—­ -->
    <main class="flex-grow relative bg-slate-100 overflow-hidden flex flex-col">
        
        <!-- ì„¤ëª… íŒ¨ë„ -->
        <div id="info-panel" class="absolute top-4 left-1/2 transform -translate-x-1/2 z-10 w-11/12 max-w-3xl pointer-events-none transition-opacity duration-300">
            <!-- JSë¡œ ë‚´ìš© ì—…ë°ì´íŠ¸ -->
        </div>

        <!-- êµ´ë¦¬ê¸° ëª¨ë“œìš© ê±°ë¦¬ í‘œì‹œ ë§í’ì„  -->
        <div id="distance-bubble" class="bubble hidden">0.0 cm</div>

        <!-- ìº”ë²„ìŠ¤ ì»¨í…Œì´ë„ˆ (ìŠ¤í¬ë¡¤ ê°€ëŠ¥) -->
        <div id="canvas-wrapper" class="w-full h-full relative bg-white overflow-x-auto overflow-y-hidden flex items-center">
            <canvas id="mainCanvas"></canvas>
        </div>
    </main>

    <script>
        // --- ì „ì—­ ë³€ìˆ˜ ë° ì„¤ì • ---
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const wrapper = document.getElementById('canvas-wrapper');
        const bubble = document.getElementById('distance-bubble');
        
        let currentTab = 'circumference'; 
        
        // ë™ì  ìŠ¤ì¼€ì¼ë§ì„ ìœ„í•œ ë³€ìˆ˜
        let pixelsPerCm = 40; 
        const MIN_PIXELS_PER_CM = 30; // ëª¨ë°”ì¼ì—ì„œë„ ì´ ì´í•˜ë¡œëŠ” ì‘ì•„ì§€ì§€ ì•ŠìŒ (ê°€ë…ì„± ë³´ì¥)
        
        let diameterCm = 4; 
        let radiusPx = 0;
        
        // ìœ„ì¹˜ ë³€ìˆ˜
        let rollX = 0; 
        let rollStartX = 0;
        let rectCx = 0;
        let rectStartX = 0;
        let triCx = 0;
        let triCenterX = 0;

        let isDragging = false;
        let isFinished = false; 
        let lastPointerX = 0;

        let splitCount = 8; 
        let transformProgress = 0; 

        const colors = {
            rectRed: '#ef4444',    
            rectBlue: '#3b82f6',   
            accent: '#ef4444',
            bg: '#f8fafc',
            text: '#334155'
        };

        function init() {
            window.addEventListener('resize', () => resizeCanvas());
            switchTab('circumference');
            
            canvas.addEventListener('mousedown', onPointerDown);
            canvas.addEventListener('touchstart', onPointerDown, {passive: false});
            window.addEventListener('mousemove', onPointerMove);
            window.addEventListener('touchmove', onPointerMove, {passive: false});
            window.addEventListener('mouseup', onPointerUp);
            window.addEventListener('touchend', onPointerUp);
        }

        // --- ë ˆì´ì•„ì›ƒ ë° í¬ê¸° ê³„ì‚° (í•˜ì´ë¸Œë¦¬ë“œ ë°˜ì‘í˜•) ---
        function calculateLayout() {
            const wrapperWidth = wrapper.clientWidth;
            const wrapperHeight = wrapper.clientHeight;
            
            // 1. í•„ìš”í•œ ì´ ê°€ë¡œ ê¸¸ì´(ë‹¨ìœ„: cm) ì˜ˆì¸¡
            const maxNeededCm = 2 + diameterCm + 1 + (diameterCm * Math.PI) + 3;
            
            // 2. í™”ë©´ì— ê½‰ ì±„ì› ì„ ë•Œì˜ ë¹„ìœ¨ ê³„ì‚°
            let possiblePPCM = wrapperWidth / maxNeededCm;
            
            // 3. ìµœì†Œ í¬ê¸° ë³´ì¥ ë¡œì§
            if (possiblePPCM < MIN_PIXELS_PER_CM) {
                pixelsPerCm = MIN_PIXELS_PER_CM;
                canvas.width = maxNeededCm * pixelsPerCm; // ìº”ë²„ìŠ¤ë¥¼ í™”ë©´ë³´ë‹¤ í¬ê²Œ ì„¤ì •
                wrapper.style.justifyContent = 'flex-start'; // ì™¼ìª½ ì •ë ¬
            } else {
                pixelsPerCm = Math.min(60, possiblePPCM);
                canvas.width = wrapperWidth; // ìº”ë²„ìŠ¤ë¥¼ í™”ë©´ì— ë§ì¶¤
                wrapper.style.justifyContent = 'center'; // ì¤‘ì•™ ì •ë ¬ (ì„ íƒì )
            }
            
            canvas.height = wrapperHeight;

            // 4. ë°˜ì§€ë¦„ ë° ì¢Œí‘œ ì¬ì„¤ì •
            radiusPx = (diameterCm * pixelsPerCm) / 2;
            
            // ìš”ì†Œ ë°°ì¹˜ ìœ„ì¹˜ (cm ë‹¨ìœ„ë¡œ ìƒê°í•˜ê³  ë³€í™˜)
            const startMargin = Math.max(canvas.width * 0.1, 80); 

            // (1) êµ´ë¦¬ê¸° ëª¨ë“œ ìœ„ì¹˜
            rollStartX = startMargin;
            
            // (2) ì§ì‚¬ê°í˜• ëª¨ë“œ ìœ„ì¹˜
            rectCx = startMargin + radiusPx; // ì™¼ìª½ ì› ì¤‘ì‹¬
            rectStartX = rectCx + (diameterCm * 2.5 * pixelsPerCm);
            
            // (3) ì‚¼ê°í˜• ëª¨ë“œ ìœ„ì¹˜
            triCx = startMargin + radiusPx; // ì™¼ìª½ ì› ì¤‘ì‹¬
            triCenterX = triCx + (diameterCm * 2.5 * pixelsPerCm);
        }

        function resizeCanvas() {
            calculateLayout();
            
            // ë¦¬ì‚¬ì´ì¦ˆ ì‹œ êµ´ë¦¬ê¸° ìœ„ì¹˜ê°€ ì–´ê¸‹ë‚˜ì§€ ì•Šë„ë¡ ì´ˆê¸°í™” (UXìƒ ì•ˆì „)
            if (currentTab === 'circumference' && !isDragging) {
               if(rollX === 0 || !isDragging) {
                   rollX = rollStartX;
                   isFinished = false;
                   bubble.classList.add('hidden');
               }
            }
            draw();
        }

        function updateDiameter() {
            const input = document.getElementById('diameterInput');
            let val = parseFloat(input.value);
            if (isNaN(val)) val = 4;
            if (val < 2) val = 2;
            if (val > 8) val = 8;
            val = Math.round(val * 10) / 10;
            
            input.value = val;
            diameterCm = val;
            
            resizeCanvas(); // ë ˆì´ì•„ì›ƒ ì¬ê³„ì‚°
            resetPosition(); 
            updateInfoPanel();
        }

        function switchTab(tabName) {
            currentTab = tabName;
            
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');
            
            document.querySelectorAll('.control-group').forEach(grp => grp.classList.add('hidden'));
            document.getElementById(`ctrl-${tabName}`).classList.remove('hidden');

            // íƒ­ ë³€ê²½ ì‹œ ì„¤ì • ì´ˆê¸°í™”
            if(tabName === 'area-rect') {
                splitCount = 8;
                document.getElementById('rect-slider').value = 0;
            } else if (tabName === 'area-tri') {
                splitCount = 4;
                document.getElementById('tri-slider').value = 0;
            }

            // ë ˆì´ì•„ì›ƒ ë‹¤ì‹œ ê³„ì‚° (íƒ­ë§ˆë‹¤ í•„ìš”í•œ ë„ˆë¹„ê°€ ë‹¤ë¥¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ)
            calculateLayout();
            rollX = rollStartX;
            transformProgress = 0;
            isFinished = false;
            bubble.classList.add('hidden'); 
            
            // ìŠ¤í¬ë¡¤ ë§¨ ì•ìœ¼ë¡œ
            wrapper.scrollLeft = 0;

            updateInfoPanel();
            draw();
        }

        function setSplit(n) {
            splitCount = n;
            draw();
            updateInfoPanel();
        }

        function updateTransform(val) {
            transformProgress = val / 100;
            draw();
        }

        // --- ê·¸ë¦¬ê¸° ë£¨í”„ ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (currentTab === 'circumference') {
                drawCircumferenceMode();
            } else if (currentTab === 'area-rect') {
                drawAreaRectMode();
            } else if (currentTab === 'area-tri') {
                drawAreaTriMode();
            }
        }

        // --- 1. ì›ì£¼ìœ¨ (êµ´ë¦¬ê¸°) ëª¨ë“œ ---
        function drawCircumferenceMode() {
            const groundY = canvas.height * 0.7;
            const dist = rollX - rollStartX;
            const distCm = dist / pixelsPerCm; 
            const rotation = dist / radiusPx;
            const circumferencePx = diameterCm * Math.PI * pixelsPerCm;

            if (dist > 0 && !isFinished) {
                bubble.style.left = rollX + 'px';
                bubble.style.top = (groundY - radiusPx - 15) + 'px';
                bubble.innerText = distCm.toFixed(1) + " cm";
                bubble.classList.remove('hidden');
            } else {
                bubble.classList.add('hidden');
            }

            // ë°”ë‹¥ì„ 
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            ctx.stroke();

            // ëˆˆê¸ˆì
            const tickStep = pixelsPerCm < 25 ? 5 : 1; 
            ctx.fillStyle = "#475569";
            ctx.font = "bold 12px sans-serif";
            ctx.textAlign = "center";
            
            const maxCm = (canvas.width - rollStartX) / pixelsPerCm;
            
            for(let i=0; i <= maxCm; i += tickStep) {
                const tx = rollStartX + (i * pixelsPerCm);
                ctx.beginPath();
                ctx.moveTo(tx, groundY);
                ctx.lineTo(tx, groundY + 10);
                ctx.strokeStyle = "#64748b";
                ctx.lineWidth = 1;
                ctx.stroke();
                
                if (i % 5 === 0 || tickStep > 1) {
                    ctx.fillText(i, tx, groundY + 25);
                }
            }

            // êµ´ëŸ¬ê°„ ìêµ­
            if(dist > 0) {
                ctx.beginPath();
                ctx.moveTo(rollStartX, groundY);
                ctx.lineTo(rollX, groundY);
                ctx.strokeStyle = colors.accent;
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.stroke();
            }

            // ëª©í‘œ ì§€ì 
            const targetX = rollStartX + circumferencePx;
            ctx.beginPath();
            ctx.moveTo(targetX, groundY - 30);
            ctx.lineTo(targetX, groundY + 30);
            ctx.strokeStyle = '#3b82f6';
            ctx.setLineDash([5,5]);
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#3b82f6';
            ctx.fillText("í•œ ë°”í€´", targetX, groundY - 40);

            // ì› ê·¸ë¦¬ê¸°
            ctx.save();
            ctx.translate(rollX, groundY - radiusPx);
            ctx.rotate(rotation);
            
            ctx.beginPath();
            ctx.arc(0, 0, radiusPx, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
            ctx.fill();
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // ë°”ë‹¥ì 
            ctx.beginPath();
            ctx.arc(0, radiusPx, 5, 0, Math.PI*2); 
            ctx.fillStyle = colors.accent;
            ctx.fill();

            ctx.restore();
            
            ctx.fillStyle = "#333";
            ctx.fillText("ì¶œë°œ", rollStartX, groundY - 50);

            if (dist >= circumferencePx - 1 && !isFinished) { 
                isFinished = true;
                updateInfoPanel(); 
            }
        }

        // --- 2. ì›ì˜ ë„“ì´ (ì§ì‚¬ê°í˜•) ëª¨ë“œ (ìƒ‰ìƒ ê·¸ë£¹í™” ìˆ˜ì •) ---
        function drawAreaRectMode() {
            const cy = canvas.height / 2;
            
            ctx.save();
            ctx.translate(rectCx, cy);
            
            ctx.beginPath();
            ctx.arc(0, 0, radiusPx, 0, Math.PI*2);
            ctx.strokeStyle = '#cbd5e1';
            ctx.stroke();

            const angleStep = (Math.PI * 2) / splitCount;
            const rectTotalWidth = Math.PI * radiusPx;
            const pieceWidth = rectTotalWidth / (splitCount / 2); 
            const halfSplit = splitCount / 2;

            // ìˆœì„œë¥¼ ì¡°ê° ë²ˆí˜¸(i)ë¡œ ë£¨í”„
            for (let i = 0; i < splitCount; i++) {
                const startAngle = i * angleStep;
                const endAngle = startAngle + angleStep;
                const midAngle = startAngle + angleStep / 2;

                const t = transformProgress;
                
                // ê·¸ë£¹í™”: 0 ~ half-1 (Bottom/Blue), half ~ splitCount-1 (Top/Red)
                const isBottomGroup = (i < halfSplit);
                
                // ì§ì‚¬ê°í˜•ì—ì„œì˜ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
                let targetX_local;
                let targetY;
                let targetRot;
                let fillColor;

                if (isBottomGroup) {
                    // íŒŒë€ìƒ‰ ì¡°ê° (ì•„ë˜ìª½, íŒì´ ìœ„ë¡œ í–¥í•¨)
                    // ìˆœì„œëŒ€ë¡œ ë°°ì¹˜ (0, 1, 2...)
                    targetX_local = i * pieceWidth; 
                    targetY = radiusPx / 2; 
                    targetRot = -Math.PI / 2; // Tip Points UP
                    fillColor = colors.rectBlue;
                } else {
                    // ë¹¨ê°„ìƒ‰ ì¡°ê° (ìœ„ìª½, íŒì´ ì•„ë˜ë¡œ í–¥í•¨)
                    // ìˆœì„œëŒ€ë¡œ ë°°ì¹˜í•˜ë˜ ë°˜ì¹¸(pieceWidth/2) ì‹œí”„íŠ¸
                    // iëŠ” halfë¶€í„° ì‹œì‘í•˜ë¯€ë¡œ (i - half)
                    targetX_local = (i - halfSplit) * pieceWidth + (pieceWidth / 2);
                    targetY = -radiusPx / 2;
                    targetRot = Math.PI / 2; // Tip Points DOWN
                    fillColor = colors.rectRed;
                }

                // ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•œ X ë³´ì •
                const targetX = (rectStartX - rectCx) + targetX_local - (rectTotalWidth / 2) + (pieceWidth/2);
                
                const curX = targetX * t; 
                const curY = targetY * t;
                
                ctx.save();
                ctx.translate(curX, curY);
                // íšŒì „ ë³´ê°„: 0(ì› ìƒíƒœ ê°ë„) -> targetRot
                // ì› ìƒíƒœì—ì„œëŠ” ì¤‘ì‹¬ì—ì„œ ë»—ì–´ë‚˜ê°€ëŠ” ê°ë„ ê·¸ëŒ€ë¡œ ìˆì–´ì•¼ í•¨ -> rotate(0)
                // ì§ì‚¬ê°í˜• ìƒíƒœì—ì„œëŠ” targetRot ë°©í–¥ìœ¼ë¡œ íšŒì „í•´ì•¼ í•¨.
                // ë‹¨, í˜„ì¬ ì¢Œí‘œê³„ê°€ (curX, curY)ë¡œ ì´ë™í–ˆìŒ.
                // ì•„í¬ ê·¸ë¦´ ë•Œ (0,0) ê¸°ì¤€ startAngle~endAngle ê·¸ë¦¼.
                // ì´ë•Œì˜ ì¤‘ì‹¬ ë°©í–¥ì€ midAngle.
                // ëª©í‘œëŠ” ì´ midAngleì´ targetRotê°€ ë˜ë„ë¡ ì „ì²´ë¥¼ ëŒë¦¬ëŠ” ê²ƒ.
                // íšŒì „ëŸ‰ = targetRot - midAngle
                ctx.rotate( (targetRot - midAngle) * t );

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, radiusPx, startAngle, endAngle);
                ctx.closePath();
                
                ctx.fillStyle = fillColor;
                ctx.fill();
                if(splitCount < 64) {
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = pixelsPerCm > 20 ? 1 : 0.5;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            ctx.restore();

            if (transformProgress > 0.8) {
                const rectW = Math.PI * radiusPx;
                const finalStartX = rectStartX - (rectW/2) + (rectTotalWidth / splitCount / 2); 
                
                const labelY = cy + radiusPx/2 + 25;
                ctx.beginPath();
                ctx.moveTo(finalStartX, labelY);
                ctx.lineTo(finalStartX + rectW, labelY);
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(finalStartX, labelY - 5);
                ctx.lineTo(finalStartX, labelY + 5);
                ctx.moveTo(finalStartX + rectW, labelY - 5);
                ctx.lineTo(finalStartX + rectW, labelY + 5);
                ctx.stroke();

                ctx.fillStyle = '#334155';
                ctx.font = "bold 12px sans-serif";
                ctx.textAlign = 'center';
                ctx.fillText("ê°€ë¡œ = ì›ì£¼ Ã— 1/2", finalStartX + rectW/2, labelY + 15);

                const labelX = finalStartX + rectW + 10;
                const topY = cy - radiusPx/2;
                const bottomY = cy + radiusPx/2;
                
                ctx.beginPath();
                ctx.moveTo(labelX, topY);
                ctx.lineTo(labelX, bottomY);
                ctx.stroke();
                
                ctx.beginPath(); 
                ctx.moveTo(labelX - 5, topY);
                ctx.lineTo(labelX + 5, topY);
                ctx.moveTo(labelX - 5, bottomY);
                ctx.lineTo(labelX + 5, bottomY);
                ctx.stroke();

                ctx.textAlign = 'left';
                ctx.fillText("ì„¸ë¡œ = (ë°˜ì§€ë¦„)", labelX + 8, cy + 4);
            }
        }

        // --- 3. ì›ì˜ ë„“ì´ (ì‚¼ê°í˜•) ëª¨ë“œ ---
        function drawAreaTriMode() {
            const cy = canvas.height * 0.75; 
            
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(canvas.width, cy);
            ctx.strokeStyle = '#cbd5e1';
            ctx.stroke();

            const ringWidth = radiusPx / splitCount;

            for (let i = 0; i < splitCount; i++) {
                const currentOuterR = radiusPx - (i * ringWidth); 
                const midR = currentOuterR - (ringWidth/2);
                const stripLen = 2 * Math.PI * midR; 
                
                const colorVal = 100 + (i * (155/splitCount));
                const color = `rgb(${colorVal}, ${100}, 255)`;

                const t = transformProgress;
                const targetY = cy - (i * ringWidth) - (ringWidth/2);
                const circleCenterY = cy - radiusPx;
                const startLegY = circleCenterY + midR;
                const curLegY = startLegY + (targetY - startLegY) * t;

                const curX = triCx + (triCenterX - triCx) * t;

                const maxAngle = 2 * Math.PI;
                const minAngle = 0.01; 
                const angle = maxAngle * (1 - t) + minAngle * t;
                const r_morph = stripLen / angle;
                const sag = r_morph * (1 - Math.cos(angle / 2));
                const arcCX = curX;
                const arcCY = curLegY - sag + r_morph;
                
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = ringWidth - 0.5; 
                if (ctx.lineWidth < 1) ctx.lineWidth = 1;
                
                ctx.arc(arcCX, arcCY, r_morph, -Math.PI/2 - angle/2, -Math.PI/2 + angle/2);
                ctx.stroke();

                if (i === 0 && t > 0.9) {
                    ctx.fillStyle = "#333";
                    ctx.textAlign = "center";
                    ctx.font = "bold 12px sans-serif";
                    ctx.fillText("ë°‘ë³€ = ì›ì£¼", triCenterX, cy + 20);
                }
                if (i === splitCount - 1 && t > 0.9) {
                    const rightX = triCenterX + (stripLen/2) + 20;
                    ctx.beginPath();
                    ctx.moveTo(rightX, cy);
                    ctx.lineTo(rightX, cy - radiusPx);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(rightX-5, cy);
                    ctx.lineTo(rightX+5, cy);
                    ctx.moveTo(rightX-5, cy - radiusPx);
                    ctx.lineTo(rightX+5, cy - radiusPx);
                    ctx.stroke();

                    ctx.textAlign = "left";
                    ctx.fillText("ë†’ì´ = (ë°˜ì§€ë¦„)", rightX + 8, cy - radiusPx/2);
                }
            }
        }

        // --- ì •ë³´ íŒ¨ë„ ì—…ë°ì´íŠ¸ ---
        function updateInfoPanel() {
            const panel = document.getElementById('info-panel');
            let html = '';

            if (currentTab === 'circumference') {
                if (!isFinished) {
                    html = `
                        <div class="bg-white/95 backdrop-blur rounded-xl p-4 shadow-xl border border-indigo-200 text-center">
                            <h2 class="text-lg font-bold text-slate-800">ì§€ë¦„ì´ ${diameterCm}cmì¸ ì›</h2>
                            <p class="text-sm text-slate-600 mt-1">ì›ì„ ë“œë˜ê·¸í•˜ì—¬ ëê¹Œì§€ êµ´ë ¤ë³´ì„¸ìš”.</p>
                            <div class="mt-2 text-lg font-bold text-indigo-600 bg-indigo-50 py-2 rounded-lg">
                                ì›ì£¼ìœ¨ = ì›ì£¼ Ã· ì§€ë¦„
                            </div>
                        </div>
                    `;
                } else {
                    const circumference = (diameterCm * Math.PI).toFixed(4);
                    html = `
                        <div class="bg-white/95 backdrop-blur rounded-xl p-4 shadow-xl border-2 border-indigo-500 text-center">
                            <h2 class="text-lg font-bold text-slate-800 mb-2">ğŸ‰ ì¸¡ì • ì™„ë£Œ!</h2>
                            <div class="flex flex-wrap justify-center gap-4 text-sm md:text-base">
                                <div class="bg-slate-100 px-3 py-1 rounded">
                                    <span class="text-slate-500">ì›ì£¼ = </span>
                                    <span class="font-bold text-slate-900">${circumference} cm</span>
                                </div>
                                <div class="bg-slate-100 px-3 py-1 rounded">
                                    <span class="text-slate-500">ì§€ë¦„ = </span>
                                    <span class="font-bold text-slate-900">${diameterCm} cm</span>
                                </div>
                                <div class="bg-indigo-100 px-3 py-1 rounded border border-indigo-200">
                                    <span class="text-indigo-600 font-bold">ì›ì£¼ìœ¨ = 3.1416</span>
                                </div>
                            </div>
                            <div class="mt-2 text-xs text-slate-500">
                                (ì›ì£¼ Ã· ì§€ë¦„ = 3.141592...)
                            </div>
                        </div>
                    `;
                }
            } else if (currentTab === 'area-rect') {
                html = `
                    <div class="bg-white/95 backdrop-blur rounded-xl p-3 shadow-xl border border-blue-200 text-left w-full">
                        <h2 class="text-base font-bold text-slate-800 text-center mb-1">ì§ì‚¬ê°í˜•ì„ ì´ìš©í•œ ì›ì˜ ë„“ì´</h2>
                        <div class="text-xs md:text-sm text-slate-700 space-y-1 bg-slate-50 p-2 rounded-lg border border-slate-200">
                            <p class="font-bold text-slate-900">ë„“ì´ = ê°€ë¡œ Ã— ì„¸ë¡œ</p>
                            <p class="pl-2">= (ì›ì£¼ Ã— 1/2) Ã— (ë°˜ì§€ë¦„)</p>
                            <p class="pl-2">= <span class="text-red-600 font-extrabold">(ë°˜ì§€ë¦„) Ã— 3.14 Ã— (ë°˜ì§€ë¦„)</span></p>
                            <div class="mt-1 text-center font-bold text-indigo-700 bg-indigo-100 py-1 rounded">
                                âˆ´ ì›ì˜ ë„“ì´ = (ë°˜ì§€ë¦„) Ã— (ë°˜ì§€ë¦„) Ã— 3.14
                            </div>
                        </div>
                    </div>
                `;
            } else if (currentTab === 'area-tri') {
                html = `
                    <div class="bg-white/95 backdrop-blur rounded-xl p-3 shadow-xl border border-purple-200 text-left w-full">
                        <h2 class="text-base font-bold text-slate-800 text-center mb-1">ì‚¼ê°í˜•ì„ ì´ìš©í•œ ì›ì˜ ë„“ì´</h2>
                        <div class="text-xs md:text-sm text-slate-700 space-y-1 bg-slate-50 p-2 rounded-lg border border-slate-200">
                            <p class="font-bold text-slate-900">ë„“ì´ = ë°‘ë³€ Ã— ë†’ì´ Ã· 2</p>
                            <p class="pl-2">= ì›ì£¼ Ã— (ë°˜ì§€ë¦„) Ã· 2</p>
                            <p class="pl-2">= <span class="text-red-600 font-extrabold">(ë°˜ì§€ë¦„) Ã— 3.14 Ã— (ë°˜ì§€ë¦„)</span></p>
                            <div class="mt-1 text-center font-bold text-indigo-700 bg-indigo-100 py-1 rounded">
                                âˆ´ ì›ì˜ ë„“ì´ = (ë°˜ì§€ë¦„) Ã— (ë°˜ì§€ë¦„) Ã— 3.14
                            </div>
                        </div>
                    </div>
                `;
            }
            panel.innerHTML = html;
        }

        function onPointerDown(e) {
            if(currentTab !== 'circumference') return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            
            const groundY = canvas.height * 0.7;
            const hitRadius = radiusPx + 60;
            
            if (Math.abs(x - rollX) < hitRadius && Math.abs(y - (groundY - radiusPx)) < hitRadius) {
                isDragging = true;
                lastPointerX = e.touches ? e.touches[0].clientX : e.clientX;
                bubble.classList.remove('hidden'); 
            }
        }

        function onPointerMove(e) {
            if (!isDragging) return;
            e.preventDefault(); 
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const dx = cx - lastPointerX;
            lastPointerX = cx;

            rollX += dx;
            if (rollX < rollStartX) rollX = rollStartX;
            
            const maxDist = diameterCm * Math.PI * pixelsPerCm;
            if (rollX > rollStartX + maxDist) rollX = rollStartX + maxDist;

            draw();
        }

        function onPointerUp() {
            isDragging = false;
        }

        function resetPosition() {
            calculateLayout();
            isFinished = false;
            bubble.classList.add('hidden');
            updateInfoPanel();
            draw();
        }

        // ì‹¤í–‰
        window.onload = init;

    </script>
</body>
</html>